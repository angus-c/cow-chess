{"version":3,"sources":["../../src/server/brain/nextMove.js"],"names":[],"mappings":"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","file":"nextMove.js","sourcesContent":["// TODO: get rid of client refs\nimport profiler from '../utilities/profiler';\n\nlet movesLookup;\n\nlet bestScoreSoFar, originalPlayer, requestedDepth;\n// store in closure scope because passing it through recursion is hella messy\nlet currentRecursionScore;\n\nfunction nextMove(game) {\n  debugger;\n  const {\n    position,\n    nextPlayer,\n    config: {\n      probeDepth,\n      cutOffDepth,\n      cutOffProportion\n    }\n  } = game.state;\n  bestScoreSoFar = Number.NEGATIVE_INFINITY;\n  movesLookup = {\n    north: {},\n    south: {}\n  };\n  originalPlayer = nextPlayer;\n  requestedDepth = probeDepth;\n  const moveTime = profiler('moveTime');\n  const firstPass = getSortedMoves(originalPlayer, position, cutOffDepth);\n  const shortlist = firstPass.slice(0, firstPass.length * cutOffProportion);\n  const move = getSortedMoves(originalPlayer, position, requestedDepth, shortlist)[0];\n  move.time = moveTime.getElapsed();\n  return move;\n\n  function getSortedMoves(player, position, depth, possibleMoves) {\n    !possibleMoves && (possibleMoves = getAllPossibleMoves(player, position));\n    const scoredMoves = possibleMoves.map(move => {\n      // excuse the side effects\n      if (depth == requestedDepth) {\n        // initialize score for this move drill-down\n        currentRecursionScore = 0;\n      }\n      const score = deepScore(move, position, depth);\n      if (depth == requestedDepth) {\n        // update top level best score\n        (score > bestScoreSoFar) && (bestScoreSoFar = score);\n      }\n      move.score = score;\n      return move;\n    });\n    return scoredMoves.sort(\n      (a, b) => a.score < b.score ? 1 : -1);\n  }\n\n  function getAllPossibleMoves(player, position) {\n    const savedMoves = movesLookup[player][position];\n    if (savedMoves) {\n      return savedMoves;\n    }\n    const moves = position.reduce((moves, symbol) => {\n      debugger;\n      if (isMyPiece(player, symbol)) {\n        moves.push(...getPossibleMoves(pieces(symbol), player));\n      }\n      return moves;\n    }, []);\n\n    movesLookup[player.name][position.toStr] = moves;\n    return moves;\n  }\n\n  function deepScore(move, position, depth) {\n    let counterScore = 0, sortedReplies;\n    // TODO: cache this?\n    const shallowScore = score(move, position, depth);\n    if (move.player === originalPlayer) {\n      currentRecursionScore += shallowScore;\n    } else {\n      currentRecursionScore -= shallowScore;\n    }\n    if (depth > 0) {\n      const giveIn =\n        (move.player == originalPlayer) &&\n        (depth != requestedDepth) &&\n        (currentRecursionScore < bestScoreSoFar);\n      if (!giveIn) {\n        sortedReplies = getSortedMoves(\n          game.getOtherPlayer(move.player),\n          simulateMove(move, position),\n          depth - 1\n        );\n        move.numberOfReplies = sortedReplies.length;\n        move.bestReply = sortedReplies[0];\n        counterScore = sortedReplies[0] ? sortedReplies[0].score : 0;\n      }\n    }\n    const thisScore = shallowScore - counterScore;\n    return thisScore;\n  }\n\n  function score(move, position, depth) {\n    let score = 1;\n    const {player, captures, forwardLeft, forwardRight, backwardLeft, backwardRight} = move;\n\n    // piece capture\n    if (captures) {\n      score += captures.getValue();\n    }\n\n    // number of possible replies\n    score -= (move.numberOfReplies || 0) / 10;\n\n    // pawn support\n    // if (position[move.from] instanceof Pawn) {\n    //   if (position[forwardLeft] && (position[forwardLeft].owner === player)) {\n    //     score += 1;\n    //   }\n    //   if (position[forwardRight] && (position[forwardRight].owner === player)) {\n    //     score += 1;\n    //   }\n    // }\n    // if (\n    //   position[backwardLeft] &&\n    //   (position[backwardLeft] instanceof Pawn) &&\n    //   (position[backwardLeft].owner === player)) {\n    //     score += 1;\n    // }\n    // if (\n    //   position[backwardRight] &&\n    //   (position[backwardRight] instanceof Pawn) &&\n    //   (position[backwardRight].owner === player)) {\n    //     score += 1;\n    // }\n\n    return score;\n  }\n\n  function simulateMove(move, position) {\n    const tempPosition = [...position];\n    tempPosition.toStr = position.toStr;\n    game.updatePosition(tempPosition, move);\n    return tempPosition;\n  }\n\n  function isMyPiece(player, symbol) {\n    return (symbol != '.') && (symbol[player.case]() == symbol);\n  }\n\n  function getPossibleMoves(piece, player) {\n    const moves = [];\n    const {diagonal, cardinal, knightwards} = piece.moveDescriptor;\n    diagonal && moves.push(...piece.possibleDiagonalMoves(position));\n    cardinal && moves.push(...piece.possibleCardinalMoves(position));\n    knightwards && moves.push(...piece.possibleKnightMoves(position));\n    return moves;\n  }\n}\n\nexport default nextMove;\n"]}